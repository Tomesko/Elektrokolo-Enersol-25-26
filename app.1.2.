import streamlit as st
import pandas as pd
import numpy as np
import math
import matplotlib.pyplot as plt

# --- 1. PHYSICS CONSTANTS & CONFIGURATION ---
CONSTANTS = {
    'g': 9.81,                # Gravity (m/s^2)
    'CdA': 0.45,              # Aerodynamic drag coefficient (m^2)
    'Crr': 0.008,             # Rolling resistance coefficient
    'rho_air': 1.225,         # Air density (kg/m^3)
    'motor_efficiency': 0.85, # 85% efficiency
    'solar_real_eff': 0.70    # 70% real-world charging efficiency
}

# --- 2. LOCATION DATABASE ---
# Slope is average % incline over the route. 
# Sunlight Coeff is a multiplier for nominal panel power (0.0 - 1.0+ based on weather/latitude)
LOCATIONS = {
    "HostouÅˆ": {"slope": 1.0, "sunlight": 0.65},  # Mild terrain, moderate sun
    "Prague":  {"slope": 2.5, "sunlight": 0.60},  # Hilly city, moderate sun
    "Brno":    {"slope": 1.5, "sunlight": 0.68},  # Moderate terrain
    "Å umava":  {"slope": 4.5, "sunlight": 0.70},  # Mountains, higher altitude sun
    "Italy (Coast)": {"slope": 1.0, "sunlight": 0.95}, # Flat, strong sun
}

# --- 3. HELPER FUNCTIONS ---
def calculate_physics(weight, speed_kmh, slope_percent, assist_level, motor_nominal_w):
    """
    Calculates the power required and consumption metrics based on physics forces.
    """
    # Unit Conversions
    v = speed_kmh / 3.6  # km/h to m/s
    theta = math.atan(slope_percent / 100) # Percent to radians
    
    # Force Calculations (Newtons)
    # 1. Air Resistance: 0.5 * rho * CdA * v^2
    f_air = 0.5 * CONSTANTS['rho_air'] * CONSTANTS['CdA'] * (v**2)
    
    # 2. Rolling Resistance: m * g * Crr * cos(theta)
    f_roll = weight * CONSTANTS['g'] * CONSTANTS['Crr'] * math.cos(theta)
    
    # 3. Gravity: m * g * sin(theta)
    f_gravity = weight * CONSTANTS['g'] * math.sin(theta)
    
    # Total Resistive Force
    total_force = f_air + f_roll + f_gravity
    
    # Power Required at the wheels (Mechanical Power)
    # If going downhill significantly, power might be negative (regen), but simple motors free-wheel.
    # We will clamp min power to 0 for consumption (ignoring regen braking for this model unless specified)
    p_mech_req = max(0, total_force * v)
    
    # Motor Contribution
    # Assist Level 1-5 maps to 20% - 100% of the REQUIRED power provided by motor
    # (Remaining power is provided by the human legs)
    assist_ratio = assist_level * 0.2
    motor_mech_power = p_mech_req * assist_ratio
    
    # Cap motor power at nominal limit (Mechanical limit)
    # We assume nominal power is the max electrical input or output? 
    # Usually nominal is output. Let's cap the mechanical output.
    if motor_mech_power > motor_nominal_w:
        motor_mech_power = motor_nominal_w
        
    # Electrical Power Consumption (Accounting for efficiency)
    # P_elec = P_mech / Efficiency
    p_elec = motor_mech_power / CONSTANTS['motor_efficiency']
    
    return {
        "forces": {"Air": f_air, "Rolling": f_roll, "Gravity": f_gravity},
        "power_mech": motor_mech_power,
        "power_elec": p_elec,
        "speed_ms": v
    }

# --- 4. APP LAYOUT & LOGIC ---

st.set_page_config(page_title="Solar E-Bike Simulator", page_icon="ðŸš²", layout="wide")

st.title("ðŸš² E-Bike Range & Solar Simulator")
st.markdown("Physics-based simulation for thesis research.")

# --- SIDEBAR INPUTS ---
st.sidebar.header("1. Ride Parameters")
total_weight = st.sidebar.number_input("Total Weight (Rider + Bike) [kg]", value=100, step=5)
avg_speed = st.sidebar.slider("Average Speed [km/h]", 10, 45, 25)

st.sidebar.header("2. Battery & Motor")
battery_voltage = st.sidebar.number_input("System Voltage [V]", value=36, step=12)
battery_wh = st.sidebar.number_input("Battery Capacity [Wh]", value=500, step=50)
motor_nominal = st.sidebar.number_input("Nominal Motor Power [W]", value=250, step=250)

st.sidebar.header("3. Assist Control")
# Mapping levels 1-5 to meaningful labels
assist_lvl = st.sidebar.select_slider(
    "Assist Level", 
    options=[1, 2, 3, 4, 5],
    value=3,
    help="1 = 20% Motor Support, 5 = 100% Motor Support"
)

st.sidebar.header("4. Solar & Location")
panel_power_wp = st.sidebar.number_input("Solar Panel Peak Power [Wp]", value=50, step=10)
location_name = st.sidebar.selectbox("Select Location", list(LOCATIONS.keys()) + ["Custom Settings"])

# Logic for Custom vs Preset Location
if location_name == "Custom Settings":
    slope_input = st.sidebar.slider("Terrain Slope [%]", -5.0, 15.0, 1.0)
    sunlight_coeff = st.sidebar.slider("Sunlight Coefficient", 0.1, 1.5, 0.8)
else:
    loc_data = LOCATIONS[location_name]
    slope_input = loc_data["slope"]
    sunlight_coeff = loc_data["sunlight"]
    st.sidebar.info(f"ðŸ“ {location_name}: Slope {slope_input}%, Sun Coeff {sunlight_coeff}")

# --- CALCULATION CORE ---

# 1. Physics Calcs
phys_data = calculate_physics(total_weight, avg_speed, slope_input, assist_lvl, motor_nominal)

# 2. Consumption (Wh/km)
# Time to travel 1 km (in hours) = 1 / speed_kmh
time_per_km_h = 1 / avg_speed
energy_per_km_wh = phys_data['power_elec'] * time_per_km_h

# 3. Solar Contribution
# Solar Power Supplied = Panel * Sun * Efficiency
solar_power_supplied = panel_power_wp * sunlight_coeff * CONSTANTS['solar_real_eff']
solar_energy_per_km = solar_power_supplied * time_per_km_h

# 4. Net Consumption & Ranges
net_consumption_wh_km = energy_per_km_wh - solar_energy_per_km

# Range Calculation (Battery Only)
if energy_per_km_wh > 0:
    range_battery = battery_wh / energy_per_km_wh
else:
    range_battery = 999 # Infinite if no power needed (downhill)

# Range Calculation (With Solar)
# If solar > consumption, theoretically infinite range (until night)
if net_consumption_wh_km <= 0 and energy_per_km_wh > 0:
    range_solar = 999 
elif energy_per_km_wh <= 0:
    range_solar = 999
else:
    range_solar = battery_wh / net_consumption_wh_km

# Cap infinite ranges for display nicely
range_battery = min(range_battery, 999)
range_solar = min(range_solar, 999)
extra_km = range_solar - range_battery

# --- DASHBOARD DISPLAY ---

# Row 1: Key Metrics
col1, col2, col3 = st.columns(3)
with col1:
    st.metric("Energy Consumption", f"{energy_per_km_wh:.1f} Wh/km", delta=f"-{solar_energy_per_km:.2f} Wh/km Solar")
with col2:
    st.metric("Range (Battery Only)", f"{range_battery:.1f} km")
with col3:
    if range_solar >= 999:
        st.metric("Range (Solar Enhanced)", "âˆž km", "Self-sustaining!")
    else:
        st.metric("Range (Solar Enhanced)", f"{range_solar:.1f} km", f"+{extra_km:.1f} km")

st.divider()

# Row 2: Charts & Details
c1, c2 = st.columns([2, 1])

with c1:
    st.subheader("Range Comparison")
    
    # Prepare Data for Chart
    chart_data = pd.DataFrame({
        'Scenario': ['Battery Only', 'Battery + Solar'],
        'Range (km)': [range_battery, range_solar if range_solar < 999 else range_battery * 1.5] # Cap visual for infinite
    })
    
    # Custom matplotlib chart for better control
    fig, ax = plt.subplots(figsize=(6, 3))
    colors = ['#FF4B4B', '#4CAF50']
    bars = ax.barh(chart_data['Scenario'], chart_data['Range (km)'], color=colors)
    ax.set_xlabel("Distance (km)")
    ax.grid(axis='x', linestyle='--', alpha=0.7)
    
    # Add labels
    for bar in bars:
        width = bar.get_width()
        label = f"{width:.1f} km" if width < 900 else "Infinite/Daily Max"
        ax.text(width + 1, bar.get_y() + bar.get_height()/2, label, va='center')
        
    st.pyplot(fig)

with c2:
    st.subheader("Physics Breakdown")
    st.markdown("Perceived Resistive Forces (Newtons):")
    forces = phys_data['forces']
    
    # Simple dataframe for display
    df_forces = pd.DataFrame.from_dict(forces, orient='index', columns=['Force (N)'])
    st.dataframe(df_forces.style.format("{:.2f}"))
    
    st.markdown("---")
    st.markdown(f"**Solar Yield:** {solar_power_supplied:.1f} Watts (continuous)")
    if solar_power_supplied > phys_data['power_elec']:
        st.success("Solar generation exceeds consumption!")
    else:
        st.warning(f"Solar covers {min(100, (solar_power_supplied/phys_data['power_elec'])*100):.1f}% of needs")

# --- DEBUG / EDUCATIONAL EXPANDER ---
with st.expander("Show Calculation Logic (For Thesis Documentation)"):
    st.latex(r"P_{resist} = (F_{air} + F_{roll} + F_{slope}) \cdot v")
    st.latex(r"F_{air} = 0.5 \cdot \rho \cdot C_d A \cdot v^2 = " + f"{forces['Air']:.2f} N")
    st.latex(r"F_{roll} = mg C_{rr} \cos(\theta) = " + f"{forces['Rolling']:.2f} N")
    st.latex(r"F_{slope} = mg \sin(\theta) = " + f"{forces['Gravity']:.2f} N")
    st.write(f"Total Mechanical Power Required: {phys_data['power_mech'] / (assist_lvl*0.2) if assist_lvl > 0 else 0:.1f} W")
    st.write(f"Motor Output (Assist Lvl {assist_lvl}): {phys_data['power_mech']:.1f} W")
    st.write(f"Electrical Draw (85% eff): {phys_data['power_elec']:.1f} W")
    